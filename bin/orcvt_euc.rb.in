Encoding.default_external = "euc-jisx0213"
"
    exit
  end
  open($file_path_name,"r") do |f|
    while buf = f.gets
      if /^#{idct}/ =~ buf.chop!
        buf.gsub!(idct,"")
        buf.gsub!(/(,T)$/,"")
        return buf
      end
    end
  end
end

#----- Main -------------------------------------------------
cnt = 0 ; lcnt = 0
# 入力ファイル名のセット
in_file = set_in_f('@01-5:')
# ファイルの存在確認
if !File.exists?(in_file)
  print "ERR: no file [ " + in_file + " ]
"
  exit
end

# ファイル原本を別名で保存(copy)し入力ファイルとする
out_file = in_file
in_file = in_file + "_org"
`cp #{out_file} #{in_file}`

# 入力、出力ファイルをそれぞれオープン
open(in_file,"r") do |f|
  open(out_file,"w") do |f2|

    # 入力ファイルから1行読み込み
    while buf = f.gets
      lcnt = lcnt + 1
      ary = Array.new
      # 行末の改行コードを削除
      buf.chop!
      # デリミタをカンマとし配列にセット（０オリジン）
#     print "[IN-ARY] => " + buf + "
"
      ary = buf.split(",",-1)

      # 対象項目についてのみ処理
      flg = false
      $tgt_csv_no.each{|s|
        # 半角か全角のカタカナが存在すればメソッド h2z(String) で変換
        if /[ｦ-ﾟァ-ヴー゛゜]/e =~ ary[s-1]
          ary[s-1] = h2z(String(ary[s-1])) ; flg = true
        end
      }
      cnt = cnt + 1 if flg

      # 配列をカンマデリミタで文字列に結合
      buf = ary.join(",")
#     print "[OUT-ARY]=> " + buf + "
"
#     puts "-----------------------------------------------------------------------"
      # 文字列を出力ファイルに書き込み
      f2.puts buf
    end
  end
end
printf("**(orcvt_euc.rb)**  convert CSV file [ %s (%d lines) ]
",out_file,lcnt)
#----- Script end -------------------------------------------
