Encoding.default_external = "euc-jisx0213"
", dbname)
  printf("エンコーディング [%s]
",encoding)
  printf("ロケール [%s] [%s]
",collate, ctype)
  printf("
")
  if ("C" == collate) and ("C" == ctype)
    if encoding == "UTF8"
      printf("OK: 拡張漢字有効
")
    elsif encoding == "EUC_JP"
      printf("OK: 拡張漢字無効
")
    else
      printf("encodingが不明です。処理を中止します
")
      exit 1
    end
  else
    printf("ロケールが C 以外です。ロケールをCで作成し直すことを推奨します。
")
  end
  printf("
")
  exit 0 if lcheck
  table_name = ""
  if toeuc  && encoding == "UTF8"
    printf("データベースがEUC-JPに変換可能かチェックします...
")
  else
    printf("データベースに不正な文字が入っていないかチェックします...
")
  end
  if encoding == "UTF8"
    iconv = Iconv.new(checkcode, "UTF-8")
    regexp = UTF8MJ.map {|i,j| j}.join("|")
    IO.popen("pg_dump #{dbconnoption} #{dbname}", "r+") {|pipe|
      while line = pipe.gets
        if /^COPY (\S+)/ =~ line
          table_name = $1
        end
        begin
          if toeuc
            UTF8MJ.each {|i,j|
              line.gsub!(Regexp.new(j),i)
            }
            line.gsub!(/\xE2\x80\x94/, "\x22\x12")
          end
          if line =~ Regexp.new(regexp)
            err_file.printf("#{table_name}
")
            err_file.printf("ERROR1: %s〓%s%s
", $~.pre_match, $~, $~.post_match)
            err_count += 1
          end
          iconv.iconv(line)
        rescue Iconv::Failure => ex
          err_file.printf("#{table_name}
")
          err_file.printf("ERROR2: %s〓%s
", Iconv.iconv("UTF-8", checkcode, ex.success), ex.failed)
          err_count += 1
        end
      end
    }
    iconv.close
  elsif encoding == "EUC_JP"
    iconv = Iconv.new("ISO-2022-JP", "EUC-JP")
    IO.popen("pg_dump #{dbconnoption} #{dbname}", "r+") {|pipe|
      while line = pipe.gets
        if /^COPY (\S+)/ =~ line
          table_name = $1
        end
        begin
          iconv.iconv(line)
        rescue Iconv::Failure => ex
          err_file.printf("#{table_name}
")
          err_file.printf("ERROR2: %s〓%s
", Iconv.iconv("UTF-8", "ISO-2022-JP", ex.success), Iconv.iconv("UTF-8", "EUC-JP-MS", ex.failed))
          err_count += 1
        end
      end
    }
    iconv.close
  end
  printf("
")
  if err_count > 0
    printf("ERROR: データベースに不正な文字がありました
")
    printf("ERROR: #{ERRFILE} を参照して修正する必要があります
")
  else
    printf("OK: 不正な文字はありませんでした
")
  end
end

def dropdb(dbconnoption, dbname)
  system("dropdb #{dbconnoption}, #{dbname}")
end

def dbexist?(dbconnoption, dbname)
  sql = "SELECT count(*) FROM pg_database WHERE datname = '#{dbname}';"
  result = `psql #{dbconnoption} template1 -A -t -c \"#{sql}\"`
  return true if result.chomp.to_i == 1
end

def other_session?(dbconnoption, dbname)
  sql = "SELECT count(*) FROM pg_stat_activity WHERE datname = \'#{dbname}\';"
  result = `psql #{dbconnoption} template1 -A -t -c \"#{sql}\"`
  return true if result.chomp.to_i > 0
end

def renamedb(dbconnoption, oldname,newname)
  sql = "ALTER DATABASE #{oldname} RENAME TO #{newname};"
  puts "psql #{dbconnoption} template1 -A -c \"#{sql}\""
  system("psql #{dbconnoption} template1 -A -c \"#{sql}\"")
end

def dump_restore(dbconnoption, oldname, newname)
  begin
    restore = IO.popen("psql #{dbconnoption} --set ON_ERROR_STOP=on #{newname}", "w")
    IO.popen("pg_dump #{dbconnoption} -EUTF-8 #{oldname}", "r+") {|pipe|
      while line = pipe.gets
        # UTF-8(MS) → UTF-8(JISX0213)
        UTF8MJ.each {|i,j|
          line.gsub!(Regexp.new(j),i)
        }
        UTF8KANA.each {|i,j|
          line.gsub!(Regexp.new(i),j)
        }
        restore.puts line
      end
    }
    restore.close_write
  rescue
    restore.flush
    restore.close
    puts "ERROR:", $!
    exit
  end
end

def dump_restore_utf8ms(dbconnoption, oldname, newname)
  begin
    restore = IO.popen("psql #{dbconnoption} --set ON_ERROR_STOP=on #{newname}", "w")
    IO.popen("pg_dump #{dbconnoption} -EUTF-8 #{oldname}", "r+") {|pipe|
      while line = pipe.gets
        # UTF-8(JISX0213) → UTF-8(MS)
        UTF8MJ.each {|i,j|
          line.gsub!(Regexp.new(i),j)
        }
        restore.puts line
      end
    }
    restore.close_write
  rescue => ex
    restore.flush
    restore.close_write
    puts "ERROR: #{ex}"
    exit
  end
end

if $0 == __FILE__
  orcadb = "orca"
  host = nil
  port = nil
  dbuser = nil
  tempdb = nil
  backupdb = nil
  toeuc = nil
  check = nil
  lcheck = nil
  clean = nil

  opt = OptionParser.new
  opt.banner = "Usage: #{File.basename($0)} -[hpUetluc] [-d DB name] [-b Backup name]"
  opt.on('-h','--host HOSTNAME','データベースホスト') {|value|
    host = value
  }
  opt.on('-p','--port PORT','データベースポート') {|value|
    port = value
  }
  opt.on('-U','--username USERNAME','データベースユーザー名') {|value|
    dbuser = value
  }
  opt.on('-d','--db DB name','対象データベース名(デフォルト orca)') {|value|
    orcadb = value
  }
  opt.on('-b','--back Backup name', 'バックアップデータベース名') {|value|
    backupdb = value
  }
  opt.on('-u', '--utf8','UTF-8へ変換（デフォルト)') {|value|
    toeuc = false
  }
  opt.on('-e', '--euc','EUC-JPへ変換') {|value|
    toeuc = true
  }
  opt.on('-t', '--test','データベースのチェック') {|value|
    check = true
  }
  opt.on('-l', '--locale','データベースのロケールチェック') {|value|
    check = true
    lcheck = true
  }
  opt.on('-c', '--clean','変換後元データベースの削除') {|value|
    clean = true
  }
  opt.parse!(ARGV)

  dbconnoption = "-w "
  dbconnoption += "-h #{host} " if host
  dbconnoption += "-p #{port} " if port
  dbconnoption += "-p #{dbuser} " if dbuser
  tempdb = orcadb + TEMP_SUFIX
  backupdb = orcadb + BACKUP_SUFIX if backupdb.nil?

  if !dbexist?(dbconnoption, orcadb)
    puts "ERROR: データベース #{orcadb} がありません"
    exit 1
  end

  if check
    checkdb(dbconnoption, orcadb, toeuc, lcheck)
    exit 0
  end

  if !other_session?(dbconnoption, orcadb).nil?
    puts "ERROR: データベース #{orcadb} に接続しているアプリケーションを終了してから実行してください。"
    exit 1
  end

  count = 1
  temptempdb = tempdb
  while dbexist?(dbconnoption, tempdb)
    tempdb = temptempdb + "_" + count.to_s
    count += 1
  end

  count = 1
  tempbackup = backupdb
  while dbexist?(dbconnoption, backupdb)
    backupdb = tempbackup + "_" + count.to_s
    count += 1
  end

  if toeuc
    createdb_eucjp(dbconnoption, tempdb)
    dump_restore_utf8ms(dbconnoption, orcadb, tempdb)
  else
    createdb_utf8(dbconnoption, tempdb)
    dump_restore(dbconnoption, orcadb, tempdb)
  end
  renamedb(dbconnoption, orcadb, backupdb)
  renamedb(dbconnoption, tempdb, orcadb)
  if clean
    dropdb(dbconnoption, backupdb)
  end
  puts "OK"
end
