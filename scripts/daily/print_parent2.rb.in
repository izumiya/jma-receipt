Encoding.default_external = "euc-jisx0213"
\s*/)
word2 = word1.split(/
/)


# -----------------------------------


li_cnt1 = 0

# 実行処理
word2.each do |d2|

	fred=Tempfile.new(['tmpred','.red'])
	fred.close
	fpdf=Tempfile.new(['tmppdf','.pdf'])
	fpdf.close


# デバッグ用コード
#	puts '[' + d2 + ']'
	li_cnt1 = li_cnt1 + 1
	d2_len = d2.size	# 文字列の長さの取得

	layeroption = d2.scan(/MonpeLayerIn(.*)MonpeLayerOut/).join.gsub(/ *-L */,",").sub(/,/,"-H ")

	# 先頭30バイトは、.diaと.defファイルのファイル名部分
	# あるいは、.redファイルの拡張子を含むファイル名
	dia_file = ''
	def_file = ''
	red_file = ''
	ls_w1 = ''	# 一時用文字列領域
	ls_w1 = d2[0, 30].strip	# ファイル名を後ろの空白を除いて取得
	site_flag = d2[60, 1].strip		# site固有判定フラグの取得
	if ls_w1 =~ /.red$/
		# .redファイルである

		# Redファイル名のセット
		case	site_flag
		when	'1'
			red_file = std_form + ls_w1
		when	'2'
			red_file = site_form + ls_w1
		else
			red_file = std_form + ls_w1
		end

		lp_name = d2[30, 20].strip	# LP名のセット
		offset_x = d2[50, 5].strip				# offset-xのセット
		offset_y = d2[55, 5].strip				# offset-yのセット
		word3 = d2[61, (d2_len - 61)]	# 一時ファイルへ出力する内容のセット

		# 一時ファイルへの書き込み
		open(temp_file, "w") do |fp|
			fp.print word3
			fp.print ' ' * 20000
		end

# take patch-lib にformが存在する場合は、pathを切替える
site_red_file = site_form + ls_w1
patch_red_file = patch_form + ls_w1
     puts 'Site  file ' + ls_w1 + ' ' + site_form
     puts 'Patch file ' + ls_w1 + ' ' + patch_form
if File.exist?(site_red_file)
     puts 'Site  Hit!!' + ls_w1 + ' ' + site_form
else
  if File.exist?(patch_red_file)
     red_file = patch_red_file
     puts 'Patch Hit!!' + ls_w1 + ' ' + patch_form
  else
     puts 'Normal Hit!!' + ls_w1
  end
end

# デバッグ用の表示
		case	word3
		when	nil
			puts	'改行のみです' + '[' + String(li_cnt1) + ']'
		when	''
			puts	'改行のみです' + '[' + String(li_cnt1) + ']'
		else
			if d2 =~ /\A\s*\z/
				puts	'空白・改行です' + '[' + String(li_cnt1) + ']'
#			else
#				puts	'OK [' + String(li_cnt1) + ']'
			end
		end
		# LP名が指定されていなかったら、LP名をlp1にする
		if lp_name == ''
			lp_name = DEFAULT_LP
		end

		# offset-xが指定されていなかったら、0にする
		if offset_x == ''
			offset_x = '0'
		end
		# offset-yが指定されていなかったら、0にする
		if offset_y == ''
			offset_y = '0'
		end

#		w_exec = RED_EXEC + ' ' + red_file + ' ' + temp_file + ' -x ' + offset_x + ' -y ' + offset_y + ' -p ' + lp_name

		w_exec = RED2EMBED + ' '   + red_file + ' ' + temp_file + ' -o ' + fred.path  + ' ; ' \
               + MONPE + ' ' +  fred.path + ' -x ' + offset_x + ' -y ' + offset_y + ' -e ' + fpdf.path + ' ' + layeroption  + ' ; ' \
               + 'cat ' + fpdf.path + ' |  lpr -P ' + lp_name


# デバッグ用の表示
#		puts w_exec
# **
		# 実行前メッセージ出力
		puts	'Print Start [' + String(li_cnt1) + ']'
		# プログラムの実行
		pid = fork do
			exec w_exec
		end
		sleep 0.01	# 予期せぬエラーの回避のため、待つ(これを行わないと、ruby ver1.4上で呼び出されたスクリプトにエラーが発生する)
		# 実行したプログラムが終わるまで待つ(引数の２番目は、1.4でのエラー回避のため)
		Process.waitpid(pid, 0)


	else
#	monpe以外のファイルはエラーとする。
		exit 4
	end

	fred.unlink
	fpdf.unlink

end



# ============================================================

# 一時ファイル削除
begin
	if nil != File.size(temp_file)
		# 一時ファイルが存在する
		# 一時ファイルの削除
		File.delete(temp_file)
	end
rescue
# 例外が発生すれば、一時ファイルが存在しない
end


# ============================================================
